Spring事务无法回滚的深层性原因？
    Spring动态代理给事务埋的坑
1。为什么aop代理导致事务无法回滚？
    --aop代理调用某个方法。如果该方法内含有另一个方法，不会走aop代理调用，而是直接调用该方法。
    --例子：
        代理"test"， 方法：test1，test2，abc三个方法名并列
            --代理会调用test1，test2，不会走abc。 --这是动态代理。
        如果方法test1，包含test2。
            --代理会调用test1，代理不会调用test2，而是test1方法完成后直接调用test2。
    --解决方法：
        1.先暴露出来aop，然后获取aop的上下文。
            --<aop:aspectj-autoproxy expose-proxy="true" />  --暴露接口。
            --AopContext.currentProxy()                 //获取当前的代理对象，后面再加要使用的代理方法。

2。jdk的动态代理？
    jdk的代理是基于接口实现的
3。SpringAop的动态代理？
    如何获取？
        --需要获取aop的上下文。

4。为什么实体中要用构造函数？构造函数的作用？
     1. 构造函数的作用
            构造函数主要用来在创建对象时完成对对象属性的一些初始化等操作, 当创建
    对象时, 对象会自动调用它的构造函数。一般来说, 构造函数有以下三个方面
    的作用:
                ■ 给创建的对象建立一个标识符;
                ■ 为对象数据成员开辟内存空间;
                ■ 完成对象数据成员的初始化。

    2. 默认构造函数
            当用户没有显式的去定义构造函数时, 编译器会为类生成一个默认的构造函数,
    称为 "默认构造函数", 默认构造函数不能完成对象数据成员的初始化, 只能给
    对象创建一标识符, 并为对象中的数据成员开辟一定的内存空间。

    3. 构造函数的特点
            无论是用户自定义的构造函数还是默认构造函数都主要有以下特点:
                ①. 在对象被创建时自动执行;
                ②. 构造函数的函数名与类名相同;
                ③. 没有返回值类型、也没有返回值;
                ④. 构造函数不能被显式调用。
5。